#!/usr/bin/env perl

use Data::Dumper;
use Socket;
use POSIX qw/:sys_wait_h strftime locale_h setsid/;
use Getopt::Long;
use constant { STAT_DEVNO=>0, STAT_INO=>1, STAT_MODE=>2, STAT_LINKS=>3, STAT_UID=>4, STAT_GID=>5, STAT_DEVIDENT=>6, STAT_SIZE=>7, STAT_ATIME=>8, STAT_MTIME=>9, STAT_CTIME=>10, STAT_PREFBLKSZ=>11, STAT_BLOCKS=>12, };


@facnam = qw/kern user mail daemon auth syslog lpr news uucp cron authpriv ftp ntp audit alert clock local0 local1 local2 local3 local4 local5 local6 local7/;
$i = 0;
%facnum = map { $_=>$i++ } @facnam;
@sevnam = qw/emerg alert crit error warning notice info debug/;
$i = 0;
%sevnum = map { $_=>$i++ } @sevnam;
undef $i;
$sevnum{'panic'} = 0;
$sevnum{'err'} = 3;
$sevnum{'warn'} = 4;

$0 = "logwall " . join(" ", @ARGV);
setlocale(LC_TIME, "C");


$sock_listen = "/dev/log";
$sock_connect = "/dev/logwall";
$rules_file = "/etc/logwall/rules";
$pid_file = "/var/run/logwall.pid";
$quiet = 0;

Getopt::Long::Configure(qw/no_ignore_case/);
GetOptions(
    'l|listen=s'    => \$sock_listen,
    'c|connect=s'   => \$sock_connect,
    'r|rules=s'     => \$rules_file,
    'P|pidfile=s'   => \$pid_file,
    'q|quiet'       => \$quiet,
)
or die("Usage: $0 [-q] [-l <frontend socket>] [-c <backend socket>] [-r <rules file>]
defaults: -l $sock_listen -c $sock_connect -r $rules_file -P $pid_file
");



sub selflog
{
	# log ourself at syslog facility
	my $str = mklogline($facnum{'syslog'}, $_[0], strftime("%b %e %H:%M:%S", localtime), "logwall[$$]:", $_[1]);
	print STDERR $str if !$quiet;
	print $backend $str;
}

sub mklogline
{
	my ($facility, $severity, $datetime, $tag, $msg) = @_;
	my $priority = ($facility << 3) + $severity;
	return sprintf "<$priority>%s %s%s\x00", $datetime, defined $tag ? "$tag " : "", $msg;
}

sub peerdata
{
	my $args;
	my @args;
	my $comm;
	my ($realpid, $puid, $pgid) = unpack('lll', getsockopt($_[0], SOL_SOCKET, SO_PEERCRED));
	my $exe = readlink "/proc/$realpid/exe";
	
	open my $fh, '<', "/proc/$realpid/cmdline";
	$args .= $_ while <$fh>;
	close $fh;
	$args =~ s/\x00$//;
	@args = split /\x00/, $args;
	$args =~ s/\x00/ /g;
	$args =~ s/[^\x20-\x7E]/sprintf '\x%02X', ord$&/eg;
	
	open my $fh, '<', "/proc/$realpid/comm";
	$comm .= $_ while <$fh>;
	$comm =~ s/[\r\n]*$//;
	close $fh;
	
	return ($realpid, $puid, $pgid, $exe, $args, $comm, @args);
}

sub logwall
{
	my $client = shift;
	my %PeerVar;
	for my $varname (qw/realpid puid pgid exe args comm/)
	{
		$PeerVar{$varname} = shift;
	}
	my @args = @_;

	if(defined $PeerVar{"puid"})
	{
		($PeerVar{"powner"}) = getpwuid $PeerVar{"puid"};
	}
	if(defined $PeerVar{"pgid"})
	{
		($PeerVar{"pgroup"}) = getgrgid $PeerVar{"pgid"};
	}
	if(defined $PeerVar{"exe"})
	{
		($PeerVar{"uid"}, $PeerVar{"gid"}) = ((stat $PeerVar{"exe"})[STAT_UID, STAT_GID]);
		($PeerVar{"owner"}) = getpwuid $PeerVar{"uid"};
		($PeerVar{"group"}) = getgrgid $PeerVar{"gid"};
	}

	if(defined $PeerVar{"comm"})
	{
		my $tmpstr = $PeerVar{"comm"};
		$tmpstr =~ s/[\x00]/ /g;
		$tmpstr =~ s/[\x0A\x0D]//g;
		$tmpstr =~ s/[^\x20-\x7E]/./g;
		$0 = "logwall ($tmpstr)";
	}
	else
	{
		$0 = "logwall (n/a)";
	}

	socket($backend, AF_UNIX, SOCK_DGRAM, 0) or selflog $sevnum{'warn'}, $!;
	select $backend; $|++; select STDOUT;
	connect($backend, $sock_connect_addr) or selflog $sevnum{'warn'}, $!;
	
	local $/ = "\x00";
	while(<$client>)
	{
		my $pass = 1;
		my %rw;
		my %Var = %PeerVar;

		s/\x00$//;
		if(/^<(?'priority'\d+)>\s*(?'datetime'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [ ]?0*([12]?[0-9]|3[01]) 0*(1?[0-9]|2[0-3])(:0*([1-5]?[0-9])){2})\s+(?'tag'\S+) / ||
		   /^<(?'priority'\d+)>\s*(?'tag'\S+) /
		  )
		{
			$Var{"msg"} = $';
			my $priority = $+{'priority'};
			$Var{"facility"} = $priority >> 3;
			$Var{"severity"} = $priority & 7;
			$Var{"facility_name"} = $facnam[$Var{"facility"}];
			$Var{"severity_name"} = $sevnam[$Var{"severity"}];
			$Var{"datetime"} = $+{'datetime'} || strftime("%b %e %H:%M:%S", localtime);
			$Var{"tag"} = $+{'tag'};
			($Var{"sourcename"}) = ($Var{"tag"} =~ /^([a-z0-9_\.,\/><-]+)/i);
			($Var{"pid"}) = ($Var{"tag"} =~ /\[(\d+)\]:?$/);
		}
		else
		{
			# FIXME: invalid logline
		}
		
		seek $rules, 0, 0;
		local $/ = "\n";
		$nl = 0;
		RULES:
		while(<$rules>)
		{
			$nl++;
			
			TESTS:
			while(1)
			{
			    if(/^\s*([a-z]+)(==|!=|=~|=\*|=|!~|!\*|>=|<=|>|<|:=|\^=|\+=)("[^""]*"|\S*)/)
			    {
					$_ = $';
					my ($test, $op, $value) = ($1, $2, $3);
					$value =~ /"([^""]+)"/ and $value = $1;
					$test = lc $test;
				
					# convert string represented facility to facility number
					if($test eq 'facility' and $value !~ /^\d+$/)
					{
						if(not exists $facnum{$value})
						{
							selflog $sevnum{'err'}, "invalid facility name '$value' on line $nl";
							next TESTS;
						}
						$value = $facnum{$value};
					}
					# convert string represented severity to severity number
					elsif($test =~ /^severity|rwlog|log$/ and $value !~ /^\d+$/)
					{
						if(not exists $sevnum{$value})
						{
							selflog $sevnum{'err'}, "invalid severity name '$value' on line $nl";
							next TESTS;
						}
						$value = $sevnum{$value};
					}


					if($test eq 'then')
					{
						$value = lc $value;
						if($value eq 'drop') { $pass = 0; last RULES; }
						elsif($value eq 'accept') { $pass = 1; last RULES; }
						else { selflog $sevnum{'err'}, "keyword 'then' takes arguments: drop, accept"; }
					}
					elsif($test eq 'log')
					{
						selflog $value, join ' ', 
							map { my $str=$Var{$_}; if($str=~/ /){ $str=~s/[""]/\\$&/g; $str="\"$str\""; } sprintf "%s=%s", $_, $str; }
							qw/realpid puid pgid powner pgroup exe comm args uid gid owner group facility_name severity_name tag sourcename pid/;
					}
					elsif($test eq 'rwlog')
					{
						selflog $value, join ' ', 
							sprintf("[rewrite] facility=%s severity=%s",
								defined $rw{'facility'} ? $facnam[$rw{'facility'}] : "",
								defined $rw{'severity'} ? $sevnam[$rw{'severity'}] : ""),
							map { sprintf "%s=%s", $_, $rw{$_} } qw/tag sourcename pid/;
					}
				
					elsif($test =~ /^exe|powner|pgroup|owner|group|tag|sourcename|msg$/)
					{
						if($op eq '==') { last TESTS unless $Var{$test} eq $value; }
						elsif($op eq '!=') { last TESTS unless $Var{$test} ne $value; }
						elsif($op eq '=~') { last TESTS unless $Var{$test} =~ /$value/; }
						elsif($op eq '=*') { last TESTS unless $Var{$test} =~ /$value/i; }
						elsif($op eq '!~') { last TESTS unless $Var{$test} !~ /$value/; }
						elsif($op eq '!*') { last TESTS unless $Var{$test} !~ /$value/i; }
						elsif($op eq ':=' or $op eq '^=' or $op eq '+=')
						{
							if($test =~ /^tag|sourcename|msg$/)
							{
								$rw{$test} = $value if $op eq ':=';
								$rw{$test} = $value.$testx if $op eq '^=';
								$rw{$test} = $testx.$value if $op eq '+=';
							}
							else
							{
								selflog $sevnum{'err'}, "can not rewrite '$test' on line $nl";
							}
						}
						else
						{
							selflog $sevnum{'err'}, "keyword '$test' takes string comparasion operator, but '$op' given on line $nl";
							last TESTS;
						}
					}
					elsif($test =~ /^realpid|puid|pgid|uid|gid|facility|severity|pid$/)
					{
						$value = int $value;
						if($op =~ /^==|!=|>=|<=|>|<$/)
						{
							last TESTS unless eval qq{$Var{$test} $op $value};
						}
						elsif($op eq ':=')
						{
							if($test =~ /^facility|severity|pid$/)
							{
								$rw{$test} = $value;
							}
							else
							{
								selflog $sevnum{'err'}, "can not rewrite '$test' on line $nl";
								last TESTS;
							}
						}
						else
						{
							selflog $sevnum{'err'}, "keyword '$test' takes numeric relation operator, nut '$op' given on line $nl";
							last TESTS;
						}
					}
					else
					{
						selflog $sevnum{'err'}, "bareword in $rules_file on line $nl; valid keywords: realpid, puid, pgid, powner, pgroup, exe, uid, gid, owner, group, facility, severity, tag, sourcename, pid, msg, then, log, rwlog";
					}
			    }
			    else
			    {
					s/\s*$//;
					s/\s*(\x23.*)?$//;
					if(length)
					{
						selflog $sevnum{'err'}, "parse syntax error in $rules_file on line $nl near '$_'";
					}
					last TESTS;
				}
			}
		}
	
		if($pass)
		{
			for my $var (qw/facility severity datetime pid msg/)
			{
				$Var{$var} = defined $rw{$var} ? $rw{$var} : $Var{$var};
			}
			if(defined $rw{'tag'})
			{
				$Var{"tag"} = $rw{'tag'};
			}
			else
			{
				if(defined $rw{'sourcename'})
				{
					$Var{"tag"} = $rw{'sourcename'};
				}
				else
				{
					($Var{"tag"}) = ($Var{"tag"} =~ /^([^:[]+)/);
				}
				if(defined $Var{"pid"} and $Var{"pid"} ne "")
				{
					$Var{"tag"} .= "[".$Var{"pid"}."]";
				}
				$Var{"tag"} .= ":";
			}
			print $backend mklogline($Var{"facility"}, $Var{"severity"}, $Var{"datetime"}, $Var{"tag"}, $Var{"msg"});
		}
	}
	
	close $backend;
	close $client;
}


sub libercid
{
	for my $pid (keys %kids)
	{
		kill $_[0], $pid;
	}
	suicid();
}
sub bury
{
	for my $pid (keys %kids)
	{
		my $w = waitpid $pid, WNOHANG;
		delete $kids{$pid} if($w != 0);
	}
}
sub suicid
{
	unlink $pid_file if defined $pid_file;
	exit;
}
sub early_die
{
	print STDERR $_[0] if $quiet;
	print STDERR "$!\n";
	exit int $!;
}




$sock_listen_addr = sockaddr_un($sock_listen);
$sock_connect_addr = sockaddr_un($sock_connect);

$str = "Ruleset: $rules_file: ";
print STDERR $str if !$quiet;
open($rules, '<', $rules_file) or early_die $str;
print STDERR "Exists\n" if !$quiet;

$str = "Frontend: $sock_listen: ";
print STDERR $str if !$quiet;
#socket($frontend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
socket($frontend, AF_UNIX, SOCK_STREAM, 0) or early_die $str;
unlink($sock_listen);
bind($frontend, $sock_listen_addr) or early_die $str;
chmod(0666, $sock_listen) or warn ($quiet?$str:'')."$!\n";
chmod(0660, $sock_connect) or warn ($quiet?$str:'')."$!\n";
listen($frontend, SOMAXCONN) or early_die $str;
print STDERR "Listening\n" if !$quiet;


$fork = fork;
if($fork == 0)
{
	close STDIN;
	chdir "/";
	setsid();

	open $fh, '>', $pid_file;
	print $fh $$;
	close $fh;

	$SIG{'TERM'} = $SIG{'QUIT'} = $SIG{'INT'} = \&libercid;
	$SIG{'CHLD'} = \&bury;
	$SIG{'HUP'} = \&suicid;

    	ACCEPT:
		1 while not accept($client, $frontend);

		##<< Race-Condition >>##
		($realpid, $puid, $pgid, $exe, $args, $comm, @args) = peerdata($client);
	
		$kid = fork;
		if(not defined $kid)
		{
			warn "$!\n";
		}
		elsif($kid == 0)
		{
			undef %kids;
			undef $pid_file;
			logwall($client, $realpid, $puid, $pgid, $exe, $args, $comm, @args);
			exit;
		}
		else
		{
			$kids{$kid} = 1;
		}
	goto ACCEPT;
	exit;
}

print STDERR "logwall started, pid $fork\n" if !$quiet;

