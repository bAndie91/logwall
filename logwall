#!/usr/bin/env perl

use Data::Dumper;
use Socket;
use POSIX qw/:sys_wait_h strftime locale_h setsid mkfifo/;
use Getopt::Long;
use constant { STAT_DEVNO=>0, STAT_INO=>1, STAT_MODE=>2, STAT_LINKS=>3, STAT_UID=>4, STAT_GID=>5, STAT_DEVIDENT=>6, STAT_SIZE=>7, STAT_ATIME=>8, STAT_MTIME=>9, STAT_CTIME=>10, STAT_PREFBLKSZ=>11, STAT_BLOCKS=>12, };
use JSON;
use Fcntl ':flock';


@facnam = qw/kern user mail daemon auth syslog lpr news uucp cron authpriv ftp ntp audit alert clock local0 local1 local2 local3 local4 local5 local6 local7/;
$i = 0;
%facnum = map { $_=>$i++ } @facnam;
@sevnam = qw/emerg alert crit error warning notice info debug/;
$i = 0;
%sevnum = map { $_=>$i++ } @sevnam;
undef $i;
$sevnum{'panic'} = $sevnum{'emerg'};
$sevnum{'err'} = $sevnum{'error'};
$sevnum{'warn'} = $sevnum{'warning'};
%Names = ('severity' => \%sevnam, 'facility' => \%facnam, );
%Numbs = ('severity' => \%sevnum, 'facility' => \%facnum, );


$sock_listen = "/dev/log";
$sock_connect = "/dev/logwall";
$rules_file = "/etc/logwall/rules";
$pid_file = "/var/run/logwall.pid";
$stats_file = "/var/run/shm/logwall-stats.json";
@fifo_listeners = ();
$quiet = 0;

Getopt::Long::Configure(qw/no_ignore_case/);
GetOptions(
    'l|listen=s'    => \$sock_listen,
    'c|connect=s'   => \$sock_connect,
    'r|rules=s'     => \$rules_file,
    'P|pidfile=s'   => \$pid_file,
    'S|statsfile=s' => \$stats_file,
    'f|fifo=s@'     => \@fifo_listeners,
    'q|quiet'       => \$quiet,
)
or die("Usage: $0 [-q] [-l <frontend socket>] [-c <backend socket>] [-f <fifo> [-f <fifo> ...]] [-r <rules file>] [-P <pid file>] [-S <stats file>]
defaults: -l $sock_listen -c $sock_connect ".(join' ',map{"-f $_"}@fifo_listeners)." -r $rules_file -P $pid_file -S $stats_file
");



$0 = 'logwall ' . join(' ', @ARGV);
setlocale(LC_TIME, 'C');


sub merge_deep
{
	my $ref2 = $_[1];
	
	if(ref $ref2 eq '')
	{
		# Sum up old and new values
		$_[0] += $ref2;
	}
	elsif(ref $ref2 eq 'HASH')
	{
		if(ref $_[0] ne 'HASH')
		{
			$_[0] = {};
		}
		for my $key (keys %$ref2)
		{
			merge_deep($_[0]->{$key}, $ref2->{$key});
		}
	}
	elsif(ref $ref2 eq 'ARRAY')
	{
		if(ref $_[0] ne 'ARRAY')
		{
			$_[0] = [];
		}
		# TODO
		# should the target array be appended/patched/overwritten?
		# now it's patched
		for my $idx (0..$#$ref2)
		{
			merge_deep($_[0]->[$idx], $ref2->[$idx]);
		}
	}
	else
	{
		merge_deep($_[0], $$ref2);
	}
}

sub addstats
{
	open my $fh, '+<', $stats_file;
	flock $fh, LOCK_EX;
	local $/ = undef;
	my $stats;
	eval {
		$stats = decode_json(<$fh> || '{}');
		1;
	} or $stats = {};
	seek $fh, 0, 0;
	merge_deep($stats, $_[0]);
	print {$fh} encode_json($stats);
	truncate $fh, tell $fh;
	close $fh;
}

sub repl
{
	my $repl;
	my %D;
	my @grp;
	($repl, $D{'&'}, $D{'`'}, $D{"'"}, $D{'+'}, @grp) = @_;
	my $n = 0;
	map { $D{++$n} = $_; } @grp;
	$repl =~ s/\$(\x26\x60\x27\+[1-9])/$D{$1}/g;
	return $repl;
}

sub resolvealias
{
	my $a = shift;
	$a = "sourcename" if $a eq "ident";
	$a = "severity" if $a eq "level";
	return $a;
}

sub selflog
{
	# log ourself at syslog facility
	my $str = mklogline($facnum{'syslog'}, $_[0], strftime("%b %e %H:%M:%S", localtime), "logwall[$$]:", $_[1]);
	print STDERR $str if !$quiet;
	my $printerr = print $backend $str;
	
	addstats({
		'messages' => {
			'originated' => {
				'count' => 1,
				'facility' => {'syslog' => 1,},
				'severity' => {$sevnam[$_[0]] => 1,},
				'size' => {
					'total' => length $str,
					'message' => length $_[1],
				},
				'error' => ($printerr == 0 ? 1 : 0),
			},
		},
	});
}

sub mklogline
{
	my ($facility, $severity, $datetime, $tag, $msg) = @_;
	my $priority = ($facility << 3) + $severity;
	return sprintf "<$priority>%s %s%s\x00", $datetime, defined $tag ? "$tag " : "", $msg;
}

sub peerdata
{
	my $args;
	my @args;
	my $comm;
	my ($realpid, $puid, $pgid) = unpack('lll', getsockopt($_[0], SOL_SOCKET, SO_PEERCRED));
	my $exe = readlink "/proc/$realpid/exe";
	
	open my $fh, '<', "/proc/$realpid/cmdline";
	$args .= $_ while <$fh>;
	close $fh;
	$args =~ s/\x00$//;
	@args = split /\x00/, $args;
	$args =~ s/\x00/ /g;
	$args =~ s/[^\x20-\x7E]/sprintf '\x%02X', ord$&/eg;
	
	open my $fh, '<', "/proc/$realpid/comm";
	$comm .= $_ while <$fh>;
	$comm =~ s/[\r\n]*$//;
	close $fh;
	
	return ($realpid, $puid, $pgid, $exe, $args, $comm, @args);
}

sub logwall
{
	my $client = shift;
	my $rules;
	my %PeerVar;
	for my $varname (qw/realpid puid pgid exe args comm/)
	{
		$PeerVar{$varname} = shift;
	}
	my @args = @_;
	if($PeerVar{"realpid"} !~ /^\d+$/)
	{
		# This is a Fifo connection, 
		# the 2nd arg is the Fifo's nick name, other args are undefined.
		$PeerVar{"fifonick"} = $PeerVar{"realpid"};
		$PeerVar{"realpid"} = undef;
	}
	
	addstats({'forks' => {'count' => 1,},});
	
	
	if(defined $PeerVar{"puid"})
	{
		($PeerVar{"powner"}) = getpwuid $PeerVar{"puid"};
	}
	if(defined $PeerVar{"pgid"})
	{
		($PeerVar{"pgroup"}) = getgrgid $PeerVar{"pgid"};
	}
	if(defined $PeerVar{"exe"})
	{
		($PeerVar{"uid"}, $PeerVar{"gid"}) = ((stat $PeerVar{"exe"})[STAT_UID, STAT_GID]);
		($PeerVar{"owner"}) = getpwuid $PeerVar{"uid"};
		($PeerVar{"group"}) = getgrgid $PeerVar{"gid"};
	}
	
	if(defined $PeerVar{"comm"})
	{
		my $tmpstr = $PeerVar{"comm"};
		$tmpstr =~ s/[\x00]/ /g;
		$tmpstr =~ s/[\x0A\x0D]//g;
		$tmpstr =~ s/[^\x20-\x7E]/./g;
		$0 = "logwall: ".$PeerVar{"realpid"}." ".$tmpstr;
	}
	elsif(defined $PeerVar{"realpid"})
	{
		$0 = "logwall: ".$PeerVar{"realpid"};
	}
	else
	{
		$0 = "logwall: ".$PeerVar{"fifonick"};
	}
	
	if(!socket($backend, AF_UNIX, SOCK_DGRAM, 0))
	{
		selflog $sevnum{'crit'}, $!;
		return 0;
	}
	select $backend; $|++; select STDOUT;
	if(!connect($backend, $sock_connect_addr))
	{
		selflog $sevnum{'crit'}, $!;
		return 0;
	}
	
	if(!open $rules, '<', $rules_file)
	{
		selflog $sevnum{'crit'}, $!;
		return 0;
	}
	
	local $/;
	if(defined $PeerVar{"fifonick"}) { $/ = "\n"; }
	else { $/ = "\x00"; }
	
	while(<$client>)
	{
		my $pass = 1;
		my %rw;
		my %Var = %PeerVar;
		addstats({
			'messages' => {
				'received' => {
					'count' => 1,
					'size' => {'total' => length,},
				},
			},
		});
		
		LOG_PACKET:
		if(defined $PeerVar{"fifonick"}) { s/\r?\n//; }
		else { s/\x00$//; }
		
		if(/^<(?'priority'\d{1,3})>\s*(?'datetime'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [ ]?0*([12]?[0-9]|3[01]) 0*(1?[0-9]|2[0-3])(:0*([1-5]?[0-9])){2})\s+(?'tag'\S+) / ||
		   /^<(?'priority'\d{1,3})>\s*(?'tag'\S+) /)
		{
			$Var{"msg"} = $';
			my $priority = $+{'priority'};
			$Var{"facility"} = $priority >> 3;
			$Var{"severity"} = $priority & 7;
			$Var{"datetime"} = $+{'datetime'} || strftime("%b %e %H:%M:%S", localtime);
			$Var{"tag"} = $+{'tag'};
			($Var{"sourcename"}) = ($Var{"tag"} =~ /^([a-z0-9_\.,\/><-]+)/i);
			($Var{"pid"}) = ($Var{"tag"} =~ /\[(\d+)\]:?$/);
			
			addstats({
				'messages' => {
					'received' => {
						'facility' => {$facnam[$Var{"facility"}] => 1,},
						'severity' => {$sevnam[$Var{"severity"}] => 1,},
						'size' => {'message' => length $Var{'msg'},},
					},
				},
			});
		}
		elsif(defined $PeerVar{"fifonick"})
		{
			# Treat this line a raw log message written to a Fifo.
			$Var{"msg"} = $_;
			$Var{"facility"} = $facnum{'user'};
			$Var{"severity"} = $sevnum{'err'};
			$Var{"datetime"} = strftime("%b %e %H:%M:%S", localtime);
			$Var{"tag"} = $Var{"sourcename"} = $Var{"pid"} = '';
			
			addstats({
				'messages' => {
					'received' => {
						'fifo' => {$PeerVar{"fifonick"} => 1,},
						'size' => {'message' => length $Var{'msg'},},
					},
				},
			});
		}
		else
		{
			addstats({
				'messages' => {
					'received' => {
						'invalid' => 1,
						'size' => {'invalid' => length,},
					},
				},
			});
			
			s/[\r\n]/sprintf "\\x%02X", ord($&)/eg;
			selflog $sevnum{'error'}, "Invalid: $_\n";
			next;
		}
		
		$Var{"facility_name"} = $facnam[$Var{"facility"}];
		$Var{"severity_name"} = $sevnam[$Var{"severity"}];
		
		seek $rules, 0, 0;
		local $/ = "\n";
		$nl = 0;
		
		RULES:
		while(<$rules>)
		{
			$nl++;
			
			TESTS:
			while(1)
			{
			    if(/^\s*([a-z]+)(==|!=|=~|=\*|=|!~|!\*|>=|<=|>|<|:=|\^=|\+=|:~)("[^""]*"|\S*)/)
			    {
					$_ = $';
					my ($test, $op, $value) = ($1, $2, $3);
					$value =~ /"([^""]+)"/ and $value = $1;
					$test = resolvealias(lc $test);
					
					# convert string-represented facility/severity to facility/severity number
					if($test ~~ ['facility', 'severity'] and $value !~ /^\d+$/)
					{
						if(not exists $Numbs{$test}->{$value})
						{
							selflog $sevnum{'err'}, "invalid $test name '$value' on line $nl";
							next TESTS;
						}
						$value = $Numbs{$test}->{$value};
					}
					
					if($test eq 'then' or $test eq 'jump')
					{
						$value = lc $value;
						if($value eq 'drop') { $pass = 0; last RULES; }
						elsif($value eq 'accept') { $pass = 1; last RULES; }
						else { selflog $sevnum{'err'}, "keyword '$test' takes arguments: drop, accept"; }
					}
					elsif($test ~~ ['log', 'rwlog'])
					{
						my @all = qw/realpid puid pgid powner pgroup exe comm args uid gid owner group facility_name severity_name tag sourcename pid fifonick/;
						my ($wlevel, @attrs) = split ',', $value;
						if($wlevel !~ /^\d+$/)
						{
							if(not exists $sevnum{$wlevel})
							{
								selflog $sevnum{'err'}, "invalid severity name '$wlevel' on line $nl";
								next TESTS;
							}
							$wlevel = $sevnum{$wlevel};
						}
						
						if(not @attrs)
						{
							if($test eq 'log')
							{
								@attrs = @all;
							}
							elsif($test eq 'rwlog')
							{
								@attrs = keys %rw;
							}
						}
						else
						{
							my @newattrs;
							for my $attr (@attrs)
							{
								if($attr eq 'ALL')
								{
									push @newattrs, @all;
								}
								elsif($attr eq 'ALLRW')
								{
									push @newattrs, keys %rw;
								}
								elsif($attr =~ /^-(.+)/)
								{
									my $a = resolvealias($1);
									@newattrs = grep { $_ ne $a; } @newattrs;
								}
								else
								{
									push @newattrs, resolvealias($attr);
								}
							}
							@attrs = @newattrs;
						}
						
						selflog $wlevel, join ' ', map
						{
							my $str = $Var{$_};
							if($str =~ / /)
							{
								$str =~ s/[\x22\x5C]/\\$&/g;
								$str="\"$str\"";
							}
							sprintf "%s=%s", $_, $str;
						}@attrs;
					}
					
					elsif($test =~ /^(exe|powner|pgroup|owner|group|tag|sourcename|msg|comm|fifonick)$/)
					{
						if($op eq '==')    { last TESTS unless $Var{$test} eq $value; }
						elsif($op eq '!=') { last TESTS unless $Var{$test} ne $value; }
						elsif($op eq '=~') { last TESTS unless $Var{$test} =~ /$value/; }
						elsif($op eq '=*') { last TESTS unless $Var{$test} =~ /$value/i; }
						elsif($op eq '!~') { last TESTS unless $Var{$test} !~ /$value/; }
						elsif($op eq '!*') { last TESTS unless $Var{$test} !~ /$value/i; }
						elsif($op ~~ [':=', '^=', '+=', ':~'])
						{
							if($test =~ /^(tag|sourcename|msg)$/)
							{
								$value =~ s/\{\{(.+?)\}\}/$Var{resolvealias($1)}/eg;
								$rw{$test} = $value if $op eq ':=';
								$rw{$test} = $value.$Var{$test} if $op eq '^=';
								$rw{$test} = $Var{$test}.$value if $op eq '+=';
								if($op eq ':~')
								{
									my ($patt, $repl) = split '~', $value, 2;
									$rw{$test} =~ s{$patt}{repl($repl, $&, $`, $', $+, $1, $2, $3, $4, $5, $6, $7, $8, $9)}eg;
								}
							}
							else
							{
								selflog $sevnum{'err'}, "attribute '$test' is not rewritable on line $nl";
							}
						}
						else
						{
							selflog $sevnum{'err'}, "keyword '$test' takes string comparasion or rewrite operator, but '$op' was found on line $nl";
							last TESTS;
						}
					}
					
					elsif($test =~ /^(realpid|puid|pgid|uid|gid|facility|severity|pid)$/)
					{
						$value = int $value;
						if($op =~ /^(==|!=|>=|<=|>|<)$/)
						{
							last TESTS unless eval qq{$Var{$test} $op $value};
						}
						elsif($op eq ':=')
						{
							if($test =~ /^(facility|severity)$/)
							{
								$rw{$test} = $value;
								$rw{$test.'_name'} = $Names{$test}->{$value};
							}
							elsif($test eq 'pid')
							{
								$rw{$test} = $value;
							}
							else
							{
								selflog $sevnum{'err'}, "attribute '$test' is not rewritable on line $nl";
								last TESTS;
							}
						}
						else
						{
							selflog $sevnum{'err'}, "keyword '$test' takes numeric relation or ':=' operator, but '$op' was found on line $nl";
							last TESTS;
						}
					}
					else
					{
						selflog $sevnum{'err'}, "bareword '$test' in $rules_file on line $nl; valid keywords: realpid, puid, pgid, powner, pgroup, exe, uid, gid, owner, group, facility, severity, tag, sourcename, pid, msg, comm, fifonick, jump, log, rwlog";
						last TESTS;
					}
			    }
			    else
			    {
					s/\s*$//;
					s/\s*(\x23.*)?$//;
					if(length)
					{
						selflog $sevnum{'err'}, "parse error in $rules_file on line $nl near '$_'";
					}
					last TESTS;
				}
			}
		}
		
		if($pass)
		{
			# Apply rewrite requests.
			for my $var (qw/facility severity facility_name severity_name datetime pid msg/)
			{
				$Var{$var} = $rw{$var} if defined $rw{$var};
			}
			if(defined $rw{'tag'})
			{
				$Var{'tag'} = $rw{'tag'};
			}
			else
			{
				if(defined $rw{'sourcename'})
				{
					$Var{'tag'} = $rw{'sourcename'};
				}
				else
				{
					($Var{'tag'}) = ($Var{'tag'} =~ /^([^:[]+)/);
				}
				if(defined $Var{'pid'} and $Var{'pid'} ne '')
				{
					$Var{'tag'} .= "[".$Var{'pid'}."]";
				}
				$Var{'tag'} .= ':';
			}
			# Compose output log message.
			my $raw = mklogline($Var{'facility'}, $Var{'severity'}, $Var{'datetime'}, $Var{'tag'}, $Var{'msg'});
			# Send to syslog daemon.
			my $printerr = print $backend $raw;
			
			addstats({
				'messages' => {
					'forwarded' => {
						'count' => 1,
						'facility' => {$Var{'facility_name'} => 1,},
						'severity' => {$Var{'severity_name'} => 1,},
						'size' => {
							'total' => length $raw,
							'message' => length $Var{'msg'},
						},
						'error' => ($printerr == 0 ? 1 : 0),
					},
				},
			});
		}
	}
	
	shutdown $backend, 2;
	close $client;
	close $rules;
}

sub splitFifoSpec
{
	my ($nick, $owner, $group, $mode, $file) = split /:/, $_[0], 5;
	if($nick eq '') { ($nick) = $file =~ /([^\/]+)$/; }
	if($owner eq '') { $owner = 0; }
	if($group eq '') { $group = 0; }
	if($mode eq '') { $mode = 0666; }
	if($owner =~ /^\d+$/) { $uid = $owner; }
	else { (undef, undef, $uid) = getpwnam $owner; }
	if($group =~ /^\d+$/) { $gid = $group; }
	else { (undef, undef, $gid) = getgrnam $group; }
	return ($nick, $uid, $gid, $mode, $file);
}


sub libercid
{
	for my $pid (keys %kids)
	{
		kill $_[0], $pid;
	}
	suicid();
}
sub bury
{
	for my $pid (keys %kids)
	{
		my $w = waitpid $pid, WNOHANG;
		delete $kids{$pid} if($w != 0);
	}
}
sub suicid
{
	unlink $pid_file if defined $pid_file;
	exit;
}
sub early_die
{
	print STDERR $_[0] if $quiet;
	print STDERR "$!\n";
	exit $_[1] if defined $_[1];
	exit int $!;
}



$str = "Stats: $stats_file: ";
print STDERR $str if !$quiet;
open($stats_file, '>>', $stats_file) or early_die $str;
print STDERR "Ok\n" if !$quiet;
close $stats_file;

$sock_listen_addr = sockaddr_un($sock_listen);
$sock_connect_addr = sockaddr_un($sock_connect);

$str = "Ruleset: $rules_file: ";
print STDERR $str if !$quiet;
open($Rules_fd, '<', $rules_file) or early_die $str;
print STDERR "Exists\n" if !$quiet;
close $Rules_fd;

for my $fifospec (@fifo_listeners)
{
	my ($nick, $uid, $gid, $mode, $file) = splitFifoSpec($fifospec);
	if($nick !~ /^[a-z_]/i or $mode !~ /^\d*$/)
	{
		$! = 0;
		early_die "Invalid FIFO spec. Valid form: 'NICKNAME:OWNER:GROUP:MODE:FILEPATH', where NICKNAME must start with alphanum or empty, in latter case basename of FILEPATH will be used.", 1;
	}
	if(not defined $uid or not defined $gid)
	{
		$! = 0;
		early_die "Either Owner or Group is not exist", 1;
	}
	
	$str = "Fifo listener: $file: ";
	print STDERR $str if !$quiet;
	mkfifo $file, $mode or early_die $str;
	chown $uid, $gid, $file or early_die $str;
	print STDERR "Created" if !$quiet;
}

$str = "Backend: $sock_connect: ";
print STDERR $str if !$quiet;
socket($backend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
connect($backend, $sock_connect_addr) or early_die $str;
close $backend;
print STDERR "Tested\n" if !$quiet;

$str = "Frontend: $sock_listen: ";
print STDERR $str if !$quiet;
#socket($frontend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
socket($frontend, AF_UNIX, SOCK_STREAM, 0) or early_die $str;
setsockopt($frontend, SOL_SOCKET, SO_PASSCRED, 1);
unlink($sock_listen);
bind($frontend, $sock_listen_addr) or early_die $str;
chmod(0666, $sock_listen) or warn ($quiet?$str:'')."$!\n";
chmod(0660, $sock_connect) or warn ($quiet?$str:'')."$!\n";
listen($frontend, SOMAXCONN) or early_die $str;
print STDERR "Listening\n" if !$quiet;


$fork = fork;
if($fork == 0)
{
	close STDIN;
	chdir "/";
	setsid();
	
	open $fh, '>', $pid_file;
	print $fh $$;
	close $fh;
	
	$SIG{'TERM'} = $SIG{'QUIT'} = $SIG{'INT'} = \&libercid;
	$SIG{'CHLD'} = \&bury;
	$SIG{'HUP'} = \&suicid;
	
	
	# Start FIFO listeners
	
	for my $fifospec (@fifo_listeners)
	{
		$fifo_kid = fork;
		if(not defined $fifo_kid)
		{
			warn "$!\n";
		}
		elsif($fifo_kid == 0)
		{
			undef %kids;
			undef $pid_file;
			my ($nick, undef, undef, undef, $file) = splitFifoSpec($fifospec);
			open my $client, '<', $file;
			logwall($client, $nick);
			close $client;
			exit;
		}
		else
		{
			$kids{$fifo_kid} = 1;
		}
	}
	
	
	# Start Socket listener
	
   	ACCEPT:
		1 while not accept($client, $frontend);
		
		##<< Race-Condition >>##
		($realpid, $puid, $pgid, $exe, $args, $comm, @args) = peerdata($client);
		
		$kid = fork;
		if(not defined $kid)
		{
			warn "$!\n";
		}
		elsif($kid == 0)
		{
			undef %kids;
			undef $pid_file;
			logwall($client, $realpid, $puid, $pgid, $exe, $args, $comm, @args);
			exit;
		}
		else
		{
			$kids{$kid} = 1;
		}
	
	goto ACCEPT;
	exit;
}

print STDERR "logwall started, pid $fork\n" if !$quiet;

