#!/usr/bin/env perl

use Data::Dumper;
use Socket;
use POSIX qw/:sys_wait_h strftime locale_h setsid mkfifo/;
use Getopt::Long;
use constant { STAT_DEVNO=>0, STAT_INO=>1, STAT_MODE=>2, STAT_LINKS=>3, STAT_UID=>4, STAT_GID=>5, STAT_DEVIDENT=>6, STAT_SIZE=>7, STAT_ATIME=>8, STAT_MTIME=>9, STAT_CTIME=>10, STAT_PREFBLKSZ=>11, STAT_BLOCKS=>12, };
use JSON;
use Fcntl ':flock';
use Cwd;


@facnam = qw/kern user mail daemon auth syslog lpr news uucp cron authpriv ftp ntp audit alert clock local0 local1 local2 local3 local4 local5 local6 local7/;
$i = 0;
%facnum = map { $_=>$i++ } @facnam;
@sevnam = qw/emerg alert crit error warning notice info debug/;
$i = 0;
%sevnum = map { $_=>$i++ } @sevnam;
undef $i;
$sevnum{'panic'} = $sevnum{'emerg'};
$sevnum{'err'} = $sevnum{'error'};
$sevnum{'warn'} = $sevnum{'warning'};
%Names = ('severity' => \@sevnam, 'facility' => \@facnam, );
%Numbs = ('severity' => \%sevnum, 'facility' => \%facnum, );


$sock_listen = "/dev/log";
$sock_connect = "/dev/logwall";
$rules_file = "/etc/logwall/rules";
$stream_rules_file = "/etc/logwall/stream-rules";
$pid_file = "/var/run/logwall.pid";
$stats_file = "/var/run/shm/logwall-stats.json";
@fifo_listeners = ();
$quiet = 0;

Getopt::Long::Configure(qw/no_ignore_case/);
GetOptions(
    'l|listen=s'    => \$sock_listen,
    'c|connect=s'   => \$sock_connect,
    'r|rules=s'     => \$rules_file,
    'stream-rules=s'=> \$stream_rules_file,
    'P|pidfile=s'   => \$pid_file,
    'S|statsfile=s' => \$stats_file,
    'f|fifo=s@'     => \@fifo_listeners,
    'q|quiet'       => \$quiet,
    'help'          => sub {
    	print "Options:
 --listen, -l      Frontend socket to listen to syslog connections on ($sock_listen)
 --connect, -c     Backend socket to connect to real syslog daemon ($sock_connect)
 --rules, -r       File to read event-level rules from ($rules_file)
 --stream-rules    File to read stream-level rules from ($stream_rules_file)
 --pidfile, -P     File to write PID into ($pid_file)
 --statsfile, -S   File to write and update statistics in JSON format into ($stats_file)
 --fifo, -f        Fifo specifications to listen to raw log messages on
 --quiet, -q       Output less messages at start
";
    	exit;
    },
)
or die("Usage: $0 [-q] [-l <frontend socket>] [-c <backend socket>] [-f <fifo> [-f <fifo> ...]] [-r <rules file>] [-P <pid file>] [-S <stats file>]\n");



$0 = 'logwall ' . join(' ', @ARGV);
setlocale(LC_TIME, 'C');


sub merge_deep
{
	my $ref2 = $_[1];
	
	if(ref $ref2 eq '')
	{
		# Sum up old and new values
		$_[0] += $ref2;
	}
	elsif(ref $ref2 eq 'HASH')
	{
		if(ref $_[0] ne 'HASH')
		{
			$_[0] = {};
		}
		for my $key (keys %$ref2)
		{
			if($key ne '')  # Ignore empty keys
			{
				merge_deep($_[0]->{$key}, $ref2->{$key});
			}
		}
	}
	elsif(ref $ref2 eq 'ARRAY')
	{
		if(ref $_[0] ne 'ARRAY')
		{
			$_[0] = [];
		}
		# TODO
		# should the target array be appended/patched/overwritten?
		# now it's patched
		for my $idx (0..$#$ref2)
		{
			merge_deep($_[0]->[$idx], $ref2->[$idx]);
		}
	}
	else
	{
		merge_deep($_[0], $$ref2);
	}
}

sub addstats
{
	open my $fh, '+<', $stats_file;
	flock $fh, LOCK_EX;
	local $/ = undef;
	my $stats;
	eval {
		$stats = decode_json(<$fh> || '{}');
		1;
	} or $stats = {};
	seek $fh, 0, 0;
	merge_deep($stats, $_[0]);
	print {$fh} encode_json($stats);
	truncate $fh, tell $fh;
	close $fh;
}

sub replace_regexp
{
	my $repl;
	my %D;
	my @grp;
	($repl, $D{'&'}, $D{'`'}, $D{"'"}, $D{'+'}, @grp) = @_;
	my $n = 0;
	map { $D{++$n} = $_; } @grp;
	undef $n;
	sub replacer
	{
		my $backslashes = shift;
		my $dollar = shift;
		my $dollarchar = shift;
		my $n_bs = length $backslashes;
		my $real_escape = $n_bs % 2 == 0;
		my $replacement;
		
		if($real_escape) { $replacement = "\\" x ($n_bs/2); }
		else { $replacement = "\\" x (($n_bs-1)/2); }
		if(length $dollar)
		{
			if($real_escape) { $replacement .= $D{$dollarchar}; }
			else { $replacement .= $dollar.$dollarchar; }
		}
		return $replacement;
	}
	$repl =~ s/(?'backslashes'(\\)*)((?'dollar'\$)(?'dollarchar'[\x26\x60\x27+1-9])|)/replacer($+{'backslashes'}, $+{'dollar'}, $+{'dollarchar'})/eg;
	return $repl;
}

sub resolvealias
{
	my $a = shift;
	$a = "sourcename" if $a eq "ident";
	$a = "severity" if $a eq "level";
	return $a;
}

sub replace_templates
{
	my $strRef = shift;
	my $varRef = shift;
	my $codeRef = shift;
	if(ref $codeRef ne 'CODE'){ $codeRef = sub{ return $_[0].$_[1]; }; }
	$$strRef =~ s/(.*?)\{\{(.+?)\}\}/$codeRef->($1, $varRef->{resolvealias($2)})/eg;
}

sub selflog
{
	# log ourself at syslog facility
	my $backend = shift;
	my $str = mklogline($facnum{'syslog'}, $_[0], strftime("%b %e %H:%M:%S", localtime), "logwall[$$]:", $_[1]);
	print STDERR $str if !$quiet;
	my $printerr = print {$backend} $str;
	
	addstats({
		'messages' => {
			'originated' => {
				'count' => 1,
				'facility' => {'syslog' => 1,},
				'severity' => {$sevnam[$_[0]] => 1,},
				'size' => {
					'total' => length $str,
					'message' => length $_[1],
				},
				'error' => ($printerr == 0 ? 1 : 0),
			},
		},
	});
}

sub mklogline
{
	my ($facility, $severity, $datetime, $tag, $msg) = @_;
	my $priority = ($facility << 3) + $severity;
	return sprintf "<$priority>%s %s%s\x00", $datetime, defined $tag ? "$tag " : "", $msg;
}

sub peerdata
{
	my $exe = "";
	my $argstr = "";
	my $comm = "";
	my @args;
	my ($realpid, $puid, $pgid) = unpack('lll', getsockopt($_[0], SOL_SOCKET, SO_PEERCRED));
	
	if($realpid > 0)
	{
		$exe = readlink "/proc/$realpid/exe";
		
		open my $fh, '<', "/proc/$realpid/cmdline";
		$argstr .= $_ while <$fh>;
		close $fh;
		$argstr =~ s/\x00$//;
		@args = split /\x00/, $argstr;
		$argstr =~ s/\x00/ /g;
		$argstr =~ s/[^\x20-\x7E]/sprintf '\x%02X', ord$&/eg;
		
		open my $fh, '<', "/proc/$realpid/comm";
		$comm .= $_ while <$fh>;
		$comm =~ s/[\r\n]*$//;
		close $fh;
	}
	
	return ($realpid, $puid, $pgid, $exe, $argstr, $comm, @args);
}

sub apply_rewrites
{
	my $VarRef = shift;
	my $rwRef = shift;
	my %rw = %$rwRef;
	
	# Apply attribute rewrites
	for my $var (qw/facility severity facility_name severity_name datetime pid msg/)
	{
		$VarRef->{$var} = $rw{$var} if defined $rw{$var};
	}
	
	if(defined $rw{'tag'})
	{
		$VarRef->{'tag'} = $rw{'tag'};
	}
	else
	{
		if(defined $rw{'sourcename'})
		{
			$VarRef->{'tag'} = $rw{'sourcename'};
		}
		else
		{
			($VarRef->{'tag'}) = ($VarRef->{'tag'} =~ /^([^:[]+)/);
		}
		
		if(defined $VarRef->{'pid'} and $VarRef->{'pid'} ne '')
		{
			$VarRef->{'tag'} .= "[".$VarRef->{'pid'}."]";
		}
		$VarRef->{'tag'} .= ':';
	}
}

sub process_rules
{
	my $backend = shift;
	my $rules = shift;
	my $rules_file = shift;
	my $VarRef = shift;
	my %Var = %$VarRef;
	my $TeeStackRef = shift;
	my @TeeStack = @$TeeStackRef;
	push @TeeStack, $Var{"tee"};
	my %rw;
	my $pass = 1;
	my $nl = 0;
	
	seek $rules, 0, 0;
	local $/ = "\n";
	
	RULES:
	while(my $rule_line = <$rules>)
	{
		$nl++;
		
		TESTS:
		while(1)
		{
		    if($rule_line =~ /^\s*([a-z]+)(==|!=|=~|=\*|=|!~|!\*|>=|<=|>|<|:=|\^=|\+=|:~)("[^""]*"|\S*)/)
		    {
				$rule_line = $';
				my ($test, $op, $value) = ($1, $2, $3);
				$value = $1 if $value =~ /^"([^""]*)"$/;
				$test = resolvealias(lc $test);
				
				# Convert string-represented facility/severity to facility/severity number
				if($test ~~ ['facility', 'severity'] and $value !~ /^\d+$/)
				{
					if(not exists $Numbs{$test}->{$value})
					{
						selflog $backend, $sevnum{'err'}, "invalid $test name '$value' on line $nl";
						next TESTS;
					}
					$value = $Numbs{$test}->{$value};
				}
				
				
				# Evaluate test expression
				my $evaled_testexpr = 0;
				
				if($test ~~ ['then', 'jump', 'action'])
				{
					$value = lc $value;
					if($value eq 'drop') { $pass = 0; last RULES; }
					elsif($value eq 'accept') { $pass = 1; last RULES; }
					else { selflog $backend, $sevnum{'err'}, "keyword '$test' takes 'drop' or 'accept' on line $nl"; }
				}
				
				if($test ~~ ['log', 'rwlog'] and !$evaled_testexpr)
				{
					my @all = qw/realpid puid pgid powner pgroup exe comm args uid gid owner group facility_name severity_name tag sourcename pid fifonick tee/;
					my @allrw = grep {!/^(severity|facility)$/} keys %rw;
					my ($wlevel, @attrs) = split ',', $value;
					if($wlevel !~ /^\d+$/)
					{
						if(not exists $sevnum{$wlevel})
						{
							selflog $backend, $sevnum{'err'}, "invalid severity name '$wlevel' on line $nl";
							next TESTS;
						}
						$wlevel = $sevnum{$wlevel};
					}
					
					if(not @attrs)
					{
						if($test eq 'log')
						{
							@attrs = @all;
						}
						elsif($test eq 'rwlog')
						{
							@attrs = @allrw;
						}
					}
					else
					{
						my @newattrs;
						for my $attr (@attrs)
						{
							if($attr eq 'ALL')
							{
								push @newattrs, @all;
							}
							elsif($attr eq 'ALLRW')
							{
								push @newattrs, @allrw;
							}
							elsif($attr =~ /^-(.+)/)
							{
								my $ex = resolvealias($1);
								@newattrs = grep { $_ ne $ex; } @newattrs;
							}
							else
							{
								push @newattrs, resolvealias($attr);
							}
						}
						@attrs = @newattrs;
					}
					
					if($test eq 'log')      { $attributesRef = \%Var; }
					elsif($test eq 'rwlog') { $attributesRef = \%rw; }
					
					selflog $backend, $wlevel, join ' ', map
					{
						my $str = $attributesRef->{$_};
						if($str =~ /[ \x22\x5C]/)
						{
							$str =~ s/[\x22\x5C]/\\$&/g;
							$str="\"$str\"";
						}
						sprintf "%s=%s", $_, $str;
					}@attrs;
					
					$evaled_testexpr = 1;
				}
				
				if($test =~ /^(exe|powner|pgroup|owner|group|tag|sourcename|msg|comm|args|fifonick|tee)$/ and !$evaled_testexpr)
				{
					$evaled_testexpr = 1;
					if($op eq '==')    { last TESTS unless $Var{$test} eq $value; }
					elsif($op eq '!=') { last TESTS unless $Var{$test} ne $value; }
					elsif($op eq '=~') { last TESTS unless $Var{$test} =~ /$value/; }
					elsif($op eq '=*') { last TESTS unless $Var{$test} =~ /$value/i; }
					elsif($op eq '!~') { last TESTS unless $Var{$test} !~ /$value/; }
					elsif($op eq '!*') { last TESTS unless $Var{$test} !~ /$value/i; }
					elsif($op ~~ [':=', '^=', '+=', ':~'])
					{
						if($test =~ /^(tag|sourcename|msg)$/)
						{
							if($op eq ':~')
							{
								my ($patt, $repl) = split '~', $value, 2;
								replace_templates(\$repl, \%Var, sub {
									my ($pre, $var) = @_;
									$pre =~ s/\\+$/$&$&/;  # escape backslashes directly preceeding a template variable
									$var =~ s/[\$\\]/\\$&/g;  # escape dollar and backslashe chars in resolved variable to prevent expanding them as dollar-meta-chars
									return $pre.$var;
								});
								my $newvalue = $Var{$test};
								$newvalue =~ s{$patt}{replace_regexp($repl, $&, $`, $', $+, $1, $2, $3, $4, $5, $6, $7, $8, $9)}eg;
								$rw{$test} = $newvalue;
							}
							else
							{
								my $newvalue = $value;
								replace_templates(\$newvalue, \%Var);
								
								$rw{$test} = $newvalue if $op eq ':=';
								$rw{$test} = $newvalue.$Var{$test} if $op eq '^=';
								$rw{$test} = $Var{$test}.$newvalue if $op eq '+=';
							}
						}
						else
						{
							selflog $backend, $sevnum{'warn'}, "attribute '$test' is not rewritable on line $nl";
							$evaled_testexpr = 0;
						}
					}
					elsif($op eq '=' and $test eq 'tee')
					{
						if($value ~~ @TeeStack)
						{
							# Prevent Fork Bomb, ignore this tee.
						}
						else
						{
							my %TeeVar = %Var;
							$TeeVar{"tee"} = $value;
							apply_rewrites(\%TeeVar, \%rw);
							addstats({
								'messages' => {
									'originated' => {
										'count' => 1,
										'size' => {
											'total' => length mklogline($TeeVar{'facility'}, $TeeVar{'severity'}, $TeeVar{'datetime'}, $TeeVar{'tag'}, $TeeVar{'msg'}),
											'message' => length $TeeVar{"msg"},
										},
										'facility' => {$facnam[$TeeVar{"facility"}] => 1,},
										'severity' => {$sevnam[$TeeVar{"severity"}] => 1,},
										'fifo' => {$TeeVar{"fifonick"} => 1,},
									},
								},
							});
							my $rules_pos = tell $rules;
							process_rules_and_send_log($backend, $rules, $rules_file, \%TeeVar, \@TeeStack);
							seek $rules, $rules_pos, 0;
						}
					}
					else
					{
						if($test ne 'tee')
						{
							selflog $backend, $sevnum{'err'}, "keyword '$test' takes string comparasion or rewrite operator, but '$op' was found on line $nl";
							last TESTS;
						}
						$evaled_testexpr = 0;
					}
				}
				
				if($test =~ /^(realpid|puid|pgid|uid|gid|facility|severity|pid|tee)$/ and !$evaled_testexpr)
				{
					if($value !~ /^\d+$/)
					{
						if($test =~ /^p?([ug])id$/)
						{
							my $ent;
							if($1 eq 'u') { $ent = getpwnam $value; }
							else { $ent = getgrnam $value; }
							if(defined $ent)
							{
								$value = $ent->[2];
							}
							else
							{
								# Can not resolve user/group name.
								# Force fail this rule.
								last TESTS;
							}
						}
						elsif($test eq "tee")
						{
							selflog $backend, $sevnum{'err'}, "keyword '$test' with '$op' operator takes numeric right-value on line $nl";
							last TESTS;
						}
						else
						{
							selflog $backend, $sevnum{'err'}, "keyword '$test' takes numeric right-value on line $nl";
							last TESTS;
						}
					}
					
					if($op =~ /^(==|!=|>=|<=|>|<)$/)
					{
						my $testint = int $Var{$test};
						$evaled_testexpr = 1;
						last TESTS unless eval qq{$testint $op $value};
					}
					elsif($op eq ':=')
					{
						if($test ~~ ['facility', 'severity'])
						{
							$rw{$test} = $value;
							$rw{$test.'_name'} = $Names{$test}->[$value];
							$evaled_testexpr = 1;
						}
						elsif($test eq 'pid')
						{
							$rw{$test} = $value;
							$evaled_testexpr = 1;
						}
						else
						{
							selflog $backend, $sevnum{'warn'}, "attribute '$test' is not rewritable on line $nl";
						}
					}
					else
					{
						if($test eq 'tee')
						{
							selflog $backend, $sevnum{'err'}, "keyword 'tee' takes string or numeric comparasion operator or '=', but '$op' was found on line $nl";
						}
						else
						{
							selflog $backend, $sevnum{'err'}, "keyword '$test' takes numeric relation or ':=' operator, but '$op' was found on line $nl";
						}
						last TESTS;
					}
				}
				
				if($test =~ /^(terminator)$/ and !$evaled_testexpr)
				{
					if($op eq ':=')
					{
						my $unescape = $value;
						$unescape =~ s/\\x([[:xdigit:]]{2})/chr hex $1/eg;
						$VarRef->{$test} = $unescape;
						$evaled_testexpr = 1;
					}
					else
					{
						selflog $backend, $sevnum{'warn'}, "attribute '$test' takes ':=' operator, but '$op' was found on line $nl";
						last TESTS;
					}
				}
				
				if(!$evaled_testexpr)
				{
					selflog $backend, $sevnum{'err'}, "bareword '$test' in $rules_file on line $nl";
					last TESTS;
				}
		    }
		    
		    else
		    {
				$rule_line =~ s/\s*$//;
				$rule_line =~ s/\s*(\x23.*)?$//;
				if(length $rule_line)
				{
					selflog $backend, $sevnum{'err'}, "parse error in $rules_file on line $nl near '$rule_line'";
				}
				last TESTS;
			}
		}
	}
	
	if($pass)
	{
		apply_rewrites($VarRef, \%rw);
	}
	
	return $pass;
}

sub process_rules_and_send_log
{
	if(process_rules(@_))
	{
		my $backend = shift;
		shift;
		shift;
		my $VarRef = shift;
		my %Var = %$VarRef;
		
		# Compose output log message.
		my $raw = mklogline($Var{'facility'}, $Var{'severity'}, $Var{'datetime'}, $Var{'tag'}, $Var{'msg'});
		# Send to syslog daemon.
		my $printError = print {$backend} $raw;
		
		addstats({
			'messages' => {
				'forwarded' => {
					'count' => 1,
					'facility' => {$Var{'facility_name'} => 1,},
					'severity' => {$Var{'severity_name'} => 1,},
					'size' => {
						'total' => length $raw,
						'message' => length $Var{'msg'},
					},
					'error' => ($printError == 0 ? 1 : 0),
				},
			},
		});
	}
}

sub logwall
{
	my $client = shift;
	my $backend;
	my $rules;
	my $stream_rules;
	my %PeerVar;
	for my $varname (qw/realpid puid pgid exe args comm/)
	{
		$PeerVar{$varname} = shift;
	}
	# Note. $PeerVar{args} is the space-delimited string (argstr) containing arguments.
	# @args is the list of arguments 1-by-1 (unused).
	my @args = @_;
	if($PeerVar{"realpid"} !~ /^\d+$/)
	{
		# This is a Fifo connection, 
		# the 2nd arg is the Fifo's nick name, other args are undefined.
		$PeerVar{"fifonick"} = $PeerVar{"realpid"};
		$PeerVar{"realpid"} = 0;
	}
	else
	{
		$PeerVar{"fifonick"} = "";
	}
	
	addstats({'forks' => {'count' => 1,},});
	
	
	if(defined $PeerVar{"puid"})
	{
		($PeerVar{"powner"}) = getpwuid $PeerVar{"puid"};
	}
	if(defined $PeerVar{"pgid"})
	{
		($PeerVar{"pgroup"}) = getgrgid $PeerVar{"pgid"};
	}
	if(defined $PeerVar{"exe"})
	{
		($PeerVar{"uid"}, $PeerVar{"gid"}) = ((stat $PeerVar{"exe"})[STAT_UID, STAT_GID]);
		($PeerVar{"owner"}) = getpwuid $PeerVar{"uid"};
		($PeerVar{"group"}) = getgrgid $PeerVar{"gid"};
	}
	
	if(defined $PeerVar{"comm"})
	{
		my $tmpstr = $PeerVar{"comm"};
		$tmpstr =~ s/[\x00]/ /g;
		$tmpstr =~ s/[\x0A\x0D]//g;
		$tmpstr =~ s/[^\x20-\x7E]/#/g;
		$0 = "logwall: ".$PeerVar{"realpid"}." ".$tmpstr;
	}
	elsif($PeerVar{"realpid"} > 0)
	{
		$0 = "logwall: ".$PeerVar{"realpid"};
	}
	# else: fifonick process title has been set earlier


	if(!socket($backend, AF_UNIX, SOCK_DGRAM, 0))
	{
		selflog $backend, $sevnum{'crit'}, $!;  # FIXME: $backend is undefined here
		return 0;
	}
	if(!connect($backend, $sock_connect_addr))
	{
		selflog $backend, $sevnum{'crit'}, $!;  # FIXME: $backend is undefined here
		return 0;
	}
	select $backend;
	$|++;
	select STDOUT;
	
	
	if(!open $stream_rules, '<', $stream_rules_file)
	{
		selflog $backend, $sevnum{'crit'}, "$stream_rules_file: $!";
		return 0;
	}
	my $stream_ok = process_rules($backend, $stream_rules, $stream_rules_file, \%PeerVar);
	close $stream_rules;
	
	if($stream_ok)
	{
		if(!open $rules, '<', $rules_file)
		{
			selflog $backend, $sevnum{'crit'}, "$rules_file: $!";
			return 0;
		}
		
		local $/;
		if(not defined $PeerVar{"terminator"})
		{
			if($PeerVar{"fifonick"} ne "") { $PeerVar{"terminator"} = "\n"; }
			else { $PeerVar{"terminator"} = "\x00"; }
		}
		$/ = $PeerVar{"terminator"};
		
		DATAGRAM:
		while(<$client>)
		{
			my %Var = %PeerVar;
			addstats({
				'messages' => {
					'received' => {
						'count' => 1,
						'size' => {'total' => length,},
					},
				},
			});
			
			PROCESS_MESSAGE:
			s/\Q$PeerVar{"terminator"}\E$//;
			
			if(/^<(?'priority'\d{1,3})>\s*(?'datetime'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [ ]?0*([12]?[0-9]|3[01]) 0*(1?[0-9]|2[0-3])(:0*([1-5]?[0-9])){2})\s+(?'tag'\S+) / ||
			   /^<(?'priority'\d{1,3})>\s*(?'tag'\S+) /)
			{
				$Var{"msg"} = $';
				my $priority = $+{'priority'};
				$Var{"facility"} = $priority >> 3;
				$Var{"severity"} = $priority & 7;
				$Var{"datetime"} = $+{'datetime'} || strftime("%b %e %H:%M:%S", localtime);
				$Var{"tag"} = $+{'tag'};
				$Var{"sourcename"} = $Var{"tag"};
				$Var{"sourcename"} =~ s{([^[:print:]]|[[:/]).*}{};  # Trim everything from the first non-printable or ":", "[", "/" char.
				($Var{"pid"}) = ($Var{"tag"} =~ /\[(\d+)\]:?$/);
				
				addstats({
					'messages' => {
						'received' => {
							'facility' => {$facnam[$Var{"facility"}] => 1,},
							'severity' => {$sevnam[$Var{"severity"}] => 1,},
							'size' => {'message' => length $Var{'msg'},},
						},
					},
				});
			}
			elsif($PeerVar{"fifonick"} ne "")
			{
				# Treat this line is a raw log message written to a Fifo.
				$Var{"msg"} = $_;
				$Var{"facility"} = $facnum{'user'};
				$Var{"severity"} = $sevnum{'notice'};
				$Var{"datetime"} = strftime("%b %e %H:%M:%S", localtime);
				$Var{"tag"} = $Var{"sourcename"} = "fifo-".$PeerVar{"fifonick"};
				$Var{"pid"} = '';
				
				addstats({
					'messages' => {
						'received' => {
							'fifo' => {$PeerVar{"fifonick"} => 1,},
							'size' => {'message' => length $Var{'msg'},},
						},
					},
				});
			}
			else
			{
				addstats({
					'messages' => {
						'received' => {
							'invalid' => 1,
							'size' => {'invalid' => length,},
						},
					},
				});
				
				s/[\r\n]/sprintf "\\x%02X", ord($&)/eg;
				selflog $backend, $sevnum{'error'}, "Invalid: $_\n";
				next;
			}
			
			$Var{"facility_name"} = $facnam[$Var{"facility"}];
			$Var{"severity_name"} = $sevnam[$Var{"severity"}];
			$Var{"tee"} = "";
			
			process_rules_and_send_log($backend, $rules, $rules_file, \%Var);
		}
	}
	
	shutdown $backend, 2;
	close $rules;
}

sub splitFifoSpec
{
	my ($nick, $owner, $group, $mode, $file) = split /:/, $_[0], 5;
	if($nick eq '') { ($nick) = $file =~ /([^\/]+)$/; }
	if($owner eq '') { $owner = $>; }
	if($group eq '') { ($group) = split ' ', $); }
	if($mode eq '') { $mode = 0666; } else { $mode = oct $mode; }
	if($owner =~ /^\d+$/) { $uid = $owner; }
	else { (undef, undef, $uid) = getpwnam $owner; }
	if($group =~ /^\d+$/) { $gid = $group; }
	else { (undef, undef, $gid) = getgrnam $group; }
	return ($nick, $uid, $gid, $mode, $file);
}


sub libercid
{
	for my $pid (keys %kids)
	{
		kill $_[0], $pid;
	}
	suicid();
}
sub bury
{
	for my $pid (keys %kids)
	{
		my $w = waitpid $pid, WNOHANG;
		delete $kids{$pid} if($w != 0);
	}
}
sub suicid
{
	unlink $pid_file if defined $pid_file;
	exit;
}
sub early_die
{
	print STDERR $_[0] if $quiet or $! == 0;
	print STDERR "$!\n";
	exit int $! if $! > 0;
	exit $_[1];
}
sub absolute_path
{
	return $_[0] if $_[0] =~ /^\//;
	return Cwd::getcwd . '/' . $_[0];
}



$sock_listen = absolute_path $sock_listen;
$sock_connect = absolute_path $sock_connect;
$rules_file = absolute_path $rules_file;
$stream_rules_file = absolute_path $stream_rules_file;
$pid_file = absolute_path $pid_file;
$stats_file = absolute_path $stats_file;


$str = "Stats: $stats_file: ";
print STDERR $str if !$quiet;
open($stats_file, '>>', $stats_file) or early_die $str;
print STDERR "Writeable\n" if !$quiet;
close $stats_file;

$sock_listen_addr = sockaddr_un($sock_listen);
$sock_connect_addr = sockaddr_un($sock_connect);

$str = "Ruleset: $rules_file: ";
print STDERR $str if !$quiet;
open($Rules_fd, '<', $rules_file) or early_die $str;
print STDERR "Exists\n" if !$quiet;
close $Rules_fd;

for my $fifospec (@fifo_listeners)
{
	my ($nick, $uid, $gid, $mode, $file) = splitFifoSpec($fifospec);
	if($nick !~ /^[a-z_]/i or $mode !~ /^\d*$/)
	{
		$! = 0;
		early_die "Invalid FIFO spec. Valid form: 'NICKNAME:OWNER:GROUP:MODE:FILEPATH', where NICKNAME must start with alphanum or empty, in latter case basename of FILEPATH will be used.", 1;
	}
	if(not defined $uid or not defined $gid)
	{
		$! = 0;
		early_die "Either Owner or Group is not exist", 1;
	}
	
	$str = "Fifo listener: $file: ";
	print STDERR $str if !$quiet;
	unlink $file if -p $file;
	mkfifo $file, $mode or early_die $str;
	chown $uid, $gid, $file or early_die $str;
	print STDERR "Created\n" if !$quiet;
}

$str = "Backend: $sock_connect: ";
print STDERR $str if !$quiet;
socket($backend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
connect($backend, $sock_connect_addr) or early_die $str;
close $backend;
print STDERR "Tested\n" if !$quiet;

$str = "Frontend: $sock_listen: ";
print STDERR $str if !$quiet;
#socket($frontend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
socket($frontend, AF_UNIX, SOCK_STREAM, 0) or early_die $str;
setsockopt($frontend, SOL_SOCKET, SO_PASSCRED, 1);
unlink($sock_listen) if -S $sock_listen;
bind($frontend, $sock_listen_addr) or early_die $str;
chmod(0666, $sock_listen) or warn ($quiet?$str:'')."$!\n";
chmod(0660, $sock_connect) or warn ($quiet?$str:'')."$!\n";
listen($frontend, SOMAXCONN) or early_die $str;
print STDERR "Listening\n" if !$quiet;


$fork = fork;
if($fork == 0)
{
	close STDIN;
	chdir "/";
	setsid();
	
	open $fh, '>', $pid_file;
	print $fh $$;
	close $fh;
	
	$SIG{'TERM'} = $SIG{'QUIT'} = $SIG{'INT'} = \&libercid;
	$SIG{'CHLD'} = \&bury;
	$SIG{'HUP'} = \&suicid;
	
	
	# Start FIFO listeners
	
	for my $fifospec (@fifo_listeners)
	{
		$fifo_kid = fork;
		if(not defined $fifo_kid)
		{
			warn "$!\n";
		}
		elsif($fifo_kid == 0)
		{
			undef %kids;
			undef $pid_file;
			my ($nick, undef, undef, undef, $file) = splitFifoSpec($fifospec);
			while(1)
			{
				$0 = "logwall: $nick (closed)";
				#my $openmode = '+<';  # non blocking, continue execution
				my $openmode = '<';  # blocking until someone write onto the fifo
				open my $client, $openmode, $file;
				$0 = "logwall: $nick (open)";
				logwall($client, $nick);
				close $client;
			}
			exit;
		}
		else
		{
			$kids{$fifo_kid} = 1;
		}
	}
	
	
	# Start Socket listener
	
   	ACCEPT:
		1 while not accept($client, $frontend);
		
		##<< Race-Condition >>##
		($realpid, $puid, $pgid, $exe, $argstr, $comm, @args) = peerdata($client);
		
		$kid = fork;
		if(not defined $kid)
		{
			warn "$!\n";
		}
		elsif($kid == 0)
		{
			undef %kids;
			undef $pid_file;
			logwall($client, $realpid, $puid, $pgid, $exe, $argstr, $comm, @args);
			close $client;
			exit;
		}
		else
		{
			$kids{$kid} = 1;
		}
	
	goto ACCEPT;
	exit;
}

print STDERR "logwall started, pid $fork\n" if !$quiet;

