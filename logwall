#!/usr/bin/env perl

use Data::Dumper;
use Socket;
use POSIX qw/:sys_wait_h strftime locale_h setsid/;
use Getopt::Long;
use constant { STAT_DEVNO=>0, STAT_INO=>1, STAT_MODE=>2, STAT_LINKS=>3, STAT_UID=>4, STAT_GID=>5, STAT_DEVIDENT=>6, STAT_SIZE=>7, STAT_ATIME=>8, STAT_MTIME=>9, STAT_CTIME=>10, STAT_PREFBLKSZ=>11, STAT_BLOCKS=>12, };
use IPC::Shareable;


@facnam = qw/kern user mail daemon auth syslog lpr news uucp cron authpriv ftp ntp audit alert clock local0 local1 local2 local3 local4 local5 local6 local7/;
$i = 0;
%facnum = map { $_=>$i++ } @facnam;
@sevnam = qw/emerg alert crit error warning notice info debug/;
$i = 0;
%sevnum = map { $_=>$i++ } @sevnam;
undef $i;
$sevnum{'panic'} = 0;
$sevnum{'err'} = 3;
$sevnum{'warn'} = 4;
%Names = ('severity' => \%sevnam, 'facility' => \%facnam, );
%Numbs = ('severity' => \%sevnum, 'facility' => \%facnum, );

$0 = "logwall " . join(" ", @ARGV);
setlocale(LC_TIME, "C");


$sock_listen = "/dev/log";
$sock_connect = "/dev/logwall";
$rules_file = "/etc/logwall/rules";
$pid_file = "/var/run/logwall.pid";
$quiet = 0;

Getopt::Long::Configure(qw/no_ignore_case/);
GetOptions(
    'l|listen=s'    => \$sock_listen,
    'c|connect=s'   => \$sock_connect,
    'r|rules=s'     => \$rules_file,
    'P|pidfile=s'   => \$pid_file,
    'q|quiet'       => \$quiet,
)
or die("Usage: $0 [-q] [-l <frontend socket>] [-c <backend socket>] [-r <rules file>] [-P <pid file>]
defaults: -l $sock_listen -c $sock_connect -r $rules_file -P $pid_file
");



sub repl
{
	my $repl;
	my %D;
	my @grp;
	($repl, $D{'&'}, $D{'`'}, $D{"'"}, $D{'+'}, @grp) = @_;
	my $n = 0;
	map { $D{++$n} = $_; } @grp;
	$repl =~ s/\$(\x26\x60\x27\+[1-9])/$D{$1}/g;
	return $repl;
}

sub resolvealias
{
	my $a = shift;
	$a = "sourcename" if $a eq "ident";
	$a = "severity" if $a eq "level";
	return $a;
}

sub selflog
{
	# log ourself at syslog facility
	my $str = mklogline($facnum{'syslog'}, $_[0], strftime("%b %e %H:%M:%S", localtime), "logwall[$$]:", $_[1]);
	print STDERR $str if !$quiet;
	my $printerr = print $backend $str;
	
	$Stats->{'messages'}->{'originated'}->{'count'}++;
	$Stats->{'messages'}->{'originated'}->{'facility'}->{'syslog'}++;
	$Stats->{'messages'}->{'originated'}->{'severity'}->{$sevnam[$_[0]]}++;
	$Stats->{'messages'}->{'originated'}->{'size'}->{'total'} += length $str;
	$Stats->{'messages'}->{'originated'}->{'size'}->{'message'} += length $_[1];
	$Stats->{'messages'}->{'originated'}->{'error'}++ if $printerr == 0;
}

sub mklogline
{
	my ($facility, $severity, $datetime, $tag, $msg) = @_;
	my $priority = ($facility << 3) + $severity;
	return sprintf "<$priority>%s %s%s\x00", $datetime, defined $tag ? "$tag " : "", $msg;
}

sub peerdata
{
	my $args;
	my @args;
	my $comm;
	my ($realpid, $puid, $pgid) = unpack('lll', getsockopt($_[0], SOL_SOCKET, SO_PEERCRED));
	my $exe = readlink "/proc/$realpid/exe";
	
	open my $fh, '<', "/proc/$realpid/cmdline";
	$args .= $_ while <$fh>;
	close $fh;
	$args =~ s/\x00$//;
	@args = split /\x00/, $args;
	$args =~ s/\x00/ /g;
	$args =~ s/[^\x20-\x7E]/sprintf '\x%02X', ord$&/eg;
	
	open my $fh, '<', "/proc/$realpid/comm";
	$comm .= $_ while <$fh>;
	$comm =~ s/[\r\n]*$//;
	close $fh;
	
	return ($realpid, $puid, $pgid, $exe, $args, $comm, @args);
}

sub logwall
{
	my $client = shift;
	my $rules;
	my %PeerVar;
	for my $varname (qw/realpid puid pgid exe args comm/)
	{
		$PeerVar{$varname} = shift;
	}
	my @args = @_;
	
	tie $Stats, 'IPC::Shareable', "logwall/stats", {mode=>0664, create=>1,};
	$Stats->{'forks'}->{'count'}++;
	
	
	if(defined $PeerVar{"puid"})
	{
		($PeerVar{"powner"}) = getpwuid $PeerVar{"puid"};
	}
	if(defined $PeerVar{"pgid"})
	{
		($PeerVar{"pgroup"}) = getgrgid $PeerVar{"pgid"};
	}
	if(defined $PeerVar{"exe"})
	{
		($PeerVar{"uid"}, $PeerVar{"gid"}) = ((stat $PeerVar{"exe"})[STAT_UID, STAT_GID]);
		($PeerVar{"owner"}) = getpwuid $PeerVar{"uid"};
		($PeerVar{"group"}) = getgrgid $PeerVar{"gid"};
	}
	
	if(defined $PeerVar{"comm"})
	{
		my $tmpstr = $PeerVar{"comm"};
		$tmpstr =~ s/[\x00]/ /g;
		$tmpstr =~ s/[\x0A\x0D]//g;
		$tmpstr =~ s/[^\x20-\x7E]/./g;
		$0 = "logwall: ".$PeerVar{"realpid"}." ".$tmpstr;
	}
	else
	{
		$0 = "logwall: ".$PeerVar{"realpid"};
	}
	
	if(!socket($backend, AF_UNIX, SOCK_DGRAM, 0))
	{
		selflog $sevnum{'crit'}, $!;
		return 0;
	}
	select $backend; $|++; select STDOUT;
	if(!connect($backend, $sock_connect_addr))
	{
		selflog $sevnum{'crit'}, $!;
		return 0;
	}
	
	if(!open $rules, '<', $rules_file)
	{
		selflog $sevnum{'crit'}, $!;
		return 0;
	}
	
	local $/ = "\x00";
	while(<$client>)
	{
		my $pass = 1;
		my %rw;
		my %Var = %PeerVar;
		$Stats->{'messages'}->{'received'}->{'count'}++;
		$Stats->{'messages'}->{'received'}->{'size'}->{'total'} += length;
		
		LOG_PACKET:
		s/\x00$//;
		if(/^<(?'priority'\d+)>\s*(?'datetime'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [ ]?0*([12]?[0-9]|3[01]) 0*(1?[0-9]|2[0-3])(:0*([1-5]?[0-9])){2})\s+(?'tag'\S+) / ||
		   /^<(?'priority'\d+)>\s*(?'tag'\S+) /)
		{
			$Var{"msg"} = $';
			my $priority = $+{'priority'};
			$Var{"facility"} = $priority >> 3;
			$Var{"severity"} = $priority & 7;
			$Var{"facility_name"} = $facnam[$Var{"facility"}];
			$Var{"severity_name"} = $sevnam[$Var{"severity"}];
			$Var{"datetime"} = $+{'datetime'} || strftime("%b %e %H:%M:%S", localtime);
			$Var{"tag"} = $+{'tag'};
			($Var{"sourcename"}) = ($Var{"tag"} =~ /^([a-z0-9_\.,\/><-]+)/i);
			($Var{"pid"}) = ($Var{"tag"} =~ /\[(\d+)\]:?$/);
			
			$Stats->{'messages'}->{'received'}->{'facility'}->{$Var{'facility_name'}}++;
			$Stats->{'messages'}->{'received'}->{'severity'}->{$Var{'severity_name'}}++;
			$Stats->{'messages'}->{'received'}->{'size'}->{'message'} += length $Var{"msg"};
		}
		else
		{
			$Stats->{'messages'}->{'received'}->{'invalid'}++;
			s/[\r\n]/sprintf "\\x%02X", ord($&)/eg;
			selflog $sevnum{'error'}, "Invalid: $_\n";
			next;
		}
		
		seek $rules, 0, 0;
		local $/ = "\n";
		$nl = 0;
		
		RULES:
		while(<$rules>)
		{
			$nl++;
			
			TESTS:
			while(1)
			{
			    if(/^\s*([a-z]+)(==|!=|=~|=\*|=|!~|!\*|>=|<=|>|<|:=|\^=|\+=|:~)("[^""]*"|\S*)/)
			    {
					$_ = $';
					my ($test, $op, $value) = ($1, $2, $3);
					$value =~ /"([^""]+)"/ and $value = $1;
					$test = resolvealias(lc $test);
					
					# convert string-represented facility/severity to facility/severity number
					if($test ~~ ['facility', 'severity'] and $value !~ /^\d+$/)
					{
						if(not exists $Numbs{$test}->{$value})
						{
							selflog $sevnum{'err'}, "invalid $test name '$value' on line $nl";
							next TESTS;
						}
						$value = $Numbs{$test}->{$value};
					}
					
					if($test eq 'then' or $test eq 'jump')
					{
						$value = lc $value;
						if($value eq 'drop') { $pass = 0; last RULES; }
						elsif($value eq 'accept') { $pass = 1; last RULES; }
						else { selflog $sevnum{'err'}, "keyword '$test' takes arguments: drop, accept"; }
					}
					elsif($test ~~ ['log', 'rwlog'])
					{
						my @all = qw/realpid puid pgid powner pgroup exe comm args uid gid owner group facility_name severity_name tag sourcename pid/;
						my ($wlevel, @attrs) = split ',', $value;
						if($wlevel !~ /^\d+$/)
						{
							if(not exists $sevnum{$wlevel})
							{
								selflog $sevnum{'err'}, "invalid severity name '$wlevel' on line $nl";
								next TESTS;
							}
							$wlevel = $sevnum{$wlevel};
						}
						
						if(not @attrs)
						{
							if($test eq 'log')
							{
								@attrs = @all;
							}
							elsif($test eq 'rwlog')
							{
								@attrs = keys %rw;
							}
						}
						else
						{
							my @newattrs;
							for my $attr (@attrs)
							{
								if($attr eq 'ALL')
								{
									push @newattrs, @all;
								}
								elsif($attr eq 'ALLRW')
								{
									push @newattrs, keys %rw;
								}
								elsif($attr =~ /^-(.+)/)
								{
									my $a = resolvealias($1);
									@newattrs = grep { $_ ne $a; } @newattrs;
								}
								else
								{
									push @newattrs, resolvealias($attr);
								}
							}
							@attrs = @newattrs;
						}
						
						selflog $wlevel, join ' ', map
						{
							my $str = $Var{$_};
							if($str =~ / /)
							{
								$str =~ s/[\x22\x5C]/\\$&/g;
								$str="\"$str\"";
							}
							sprintf "%s=%s", $_, $str;
						}@attrs;
					}
					
					elsif($test =~ /^(exe|powner|pgroup|owner|group|tag|sourcename|msg|comm)$/)
					{
						if($op eq '==')    { last TESTS unless $Var{$test} eq $value; }
						elsif($op eq '!=') { last TESTS unless $Var{$test} ne $value; }
						elsif($op eq '=~') { last TESTS unless $Var{$test} =~ /$value/; }
						elsif($op eq '=*') { last TESTS unless $Var{$test} =~ /$value/i; }
						elsif($op eq '!~') { last TESTS unless $Var{$test} !~ /$value/; }
						elsif($op eq '!*') { last TESTS unless $Var{$test} !~ /$value/i; }
						elsif($op ~~ [':=', '^=', '+=', ':~'])
						{
							if($test =~ /^(tag|sourcename|msg)$/)
							{
								$value =~ s/\{\{(.+?)\}\}/$Var{resolvealias($1)}/eg;
								$rw{$test} = $value if $op eq ':=';
								$rw{$test} = $value.$Var{$test} if $op eq '^=';
								$rw{$test} = $Var{$test}.$value if $op eq '+=';
								if($op eq ':~')
								{
									my ($patt, $repl) = split '~', $value, 2;
									$rw{$test} =~ s{$patt}{repl($repl, $&, $`, $', $+, $1, $2, $3, $4, $5, $6, $7, $8, $9)}eg;
								}
							}
							else
							{
								selflog $sevnum{'err'}, "attribute '$test' is not rewritable on line $nl";
							}
						}
						else
						{
							selflog $sevnum{'err'}, "keyword '$test' takes string comparasion or rewrite operator, but '$op' was found on line $nl";
							last TESTS;
						}
					}
					
					elsif($test =~ /^(realpid|puid|pgid|uid|gid|facility|severity|pid)$/)
					{
						$value = int $value;
						if($op =~ /^(==|!=|>=|<=|>|<)$/)
						{
							last TESTS unless eval qq{$Var{$test} $op $value};
						}
						elsif($op eq ':=')
						{
							if($test =~ /^(facility|severity)$/)
							{
								$rw{$test} = $value;
								$rw{$test.'_name'} = $Names{$test}->{$value};
							}
							elsif($test eq 'pid')
							{
								$rw{$test} = $value;
							}
							else
							{
								selflog $sevnum{'err'}, "attribute '$test' is not rewritable on line $nl";
								last TESTS;
							}
						}
						else
						{
							selflog $sevnum{'err'}, "keyword '$test' takes numeric relation or ':=' operator, but '$op' was found on line $nl";
							last TESTS;
						}
					}
					else
					{
						selflog $sevnum{'err'}, "bareword '$test' in $rules_file on line $nl; valid keywords: realpid, puid, pgid, powner, pgroup, exe, uid, gid, owner, group, facility, severity, tag, sourcename, pid, msg, comm, jump, log, rwlog";
						last TESTS;
					}
			    }
			    else
			    {
					s/\s*$//;
					s/\s*(\x23.*)?$//;
					if(length)
					{
						selflog $sevnum{'err'}, "parse syntax error in $rules_file on line $nl near '$_'";
					}
					last TESTS;
				}
			}
		}
		
		if($pass)
		{
			for my $var (qw/facility severity facility_name severity_name datetime pid msg/)
			{
				$Var{$var} = $rw{$var} if defined $rw{$var};
			}
			if(defined $rw{'tag'})
			{
				$Var{'tag'} = $rw{'tag'};
			}
			else
			{
				if(defined $rw{'sourcename'})
				{
					$Var{'tag'} = $rw{'sourcename'};
				}
				else
				{
					($Var{'tag'}) = ($Var{'tag'} =~ /^([^:[]+)/);
				}
				if(defined $Var{'pid'} and $Var{'pid'} ne '')
				{
					$Var{'tag'} .= "[".$Var{'pid'}."]";
				}
				$Var{'tag'} .= ':';
			}
			my $raw = mklogline($Var{'facility'}, $Var{'severity'}, $Var{'datetime'}, $Var{'tag'}, $Var{'msg'});
			my $printerr = print $backend $raw;
			
			$Stats->{'messages'}->{'forwarded'}->{'count'}++;
			$Stats->{'messages'}->{'forwarded'}->{'facility'}->{$Var{'facility_name'}}++;
			$Stats->{'messages'}->{'forwarded'}->{'severity'}->{$Var{'severity_name'}}++;
			$Stats->{'messages'}->{'forwarded'}->{'size'}->{'total'} += length $raw;
			$Stats->{'messages'}->{'forwarded'}->{'size'}->{'message'} += length $Var{'msg'};
			$Stats->{'messages'}->{'forwarded'}->{'error'}++ if $printerr == 0;
		}
	}
	
	close $backend;
	close $client;
	close $rules;
}


sub libercid
{
	for my $pid (keys %kids)
	{
		kill $_[0], $pid;
	}
	suicid();
}
sub bury
{
	for my $pid (keys %kids)
	{
		my $w = waitpid $pid, WNOHANG;
		delete $kids{$pid} if($w != 0);
	}
}
sub suicid
{
	unlink $pid_file if defined $pid_file;
	exit;
}
sub early_die
{
	print STDERR $_[0] if $quiet;
	print STDERR "$!\n";
	exit int $!;
}



$sock_listen_addr = sockaddr_un($sock_listen);
$sock_connect_addr = sockaddr_un($sock_connect);

$str = "Ruleset: $rules_file: ";
print STDERR $str if !$quiet;
open($Rules_fd, '<', $rules_file) or early_die $str;
print STDERR "Exists\n" if !$quiet;
close $Rules_fd;

$str = "Backend: $sock_connect: ";
print STDERR $str if !$quiet;
socket($backend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
connect($backend, $sock_connect_addr) or early_die $str;
close $backend;
print STDERR "Tested\n" if !$quiet;

$str = "Frontend: $sock_listen: ";
print STDERR $str if !$quiet;
#socket($frontend, AF_UNIX, SOCK_DGRAM, 0) or early_die $str;
socket($frontend, AF_UNIX, SOCK_STREAM, 0) or early_die $str;
setsockopt($frontend, SOL_SOCKET, SO_PASSCRED, 1);
unlink($sock_listen);
bind($frontend, $sock_listen_addr) or early_die $str;
chmod(0666, $sock_listen) or warn ($quiet?$str:'')."$!\n";
chmod(0660, $sock_connect) or warn ($quiet?$str:'')."$!\n";
listen($frontend, SOMAXCONN) or early_die $str;
print STDERR "Listening\n" if !$quiet;


$fork = fork;
if($fork == 0)
{
	close STDIN;
	chdir "/";
	setsid();
	
	open $fh, '>', $pid_file;
	print $fh $$;
	close $fh;
	
	$SIG{'TERM'} = $SIG{'QUIT'} = $SIG{'INT'} = \&libercid;
	$SIG{'CHLD'} = \&bury;
	$SIG{'HUP'} = \&suicid;
	
    	ACCEPT:
		1 while not accept($client, $frontend);
		
		##<< Race-Condition >>##
		($realpid, $puid, $pgid, $exe, $args, $comm, @args) = peerdata($client);
		
		$kid = fork;
		if(not defined $kid)
		{
			warn "$!\n";
		}
		elsif($kid == 0)
		{
			undef %kids;
			undef $pid_file;
			logwall($client, $realpid, $puid, $pgid, $exe, $args, $comm, @args);
			exit;
		}
		else
		{
			$kids{$kid} = 1;
		}
	
	goto ACCEPT;
	exit;
}

print STDERR "logwall started, pid $fork\n" if !$quiet;

