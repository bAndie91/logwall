#!/usr/bin/env perl

use Data::Dumper;
use Socket;
use POSIX qw/:sys_wait_h strftime locale_h/;
use Getopt::Long;
use constant { STAT_DEVNO=>0, STAT_INO=>1, STAT_MODE=>2, STAT_LINKS=>3, STAT_UID=>4, STAT_GID=>5, STAT_DEVIDENT=>6, STAT_SIZE=>7, STAT_ATIME=>8, STAT_MTIME=>9, STAT_CTIME=>10, STAT_PREFBLKSZ=>11, STAT_BLOCKS=>12 };

@facnam = qw/kern user mail daemon auth syslog lpr news uucp cron authpriv ftp ntp audit alert clock local0 local1 local2 local3 local4 local5 local6 local7/;
$i = 0;
%facnum = map { $_=>$i++ } @facnam;
@sevnam = qw/emerg alert crit error warning notice info debug/;
$i = 0;
%sevnum = map { $_=>$i++ } @sevnam;
undef $i;
$sevnum{'panic'} = 0;
$sevnum{'err'} = 3;
$sevnum{'warn'} = 4;

$0 = "logwall " . join(" ", @ARGV);
setlocale(LC_TIME, "C");


$sock_listen = "/dev/log";
$sock_connect = "/dev/logwall";
$file_rules = "/etc/logwall/rules";
$quiet = 0;

GetOptions(
    'l|listen=s'    => \$sock_listen,
    'c|connect=s'   => \$sock_connect,
    'r|rules=s'     => \$file_rules,
    'q|quiet'       => \$quiet,
)
or die("Usage: $0 [-q] [-l <frontend socket>] [-c <backend socket>] [-r <rules file>]
defaults: -l /dev/log -c /dev/logwall -r /etc/logwall/rules
");



sub yell {
	# log ourself at syslog facility
	my $str = sprintf("<%d>%s logwall[%d]: %s\n", 40 + $_[0]%8, strftime("%b %e %H:%M:%S", localtime), $$, $_[1]);
	print STDERR $str if !$quiet;
	print $backend $str;
}

sub mklogline {
	my ($facility, $severity, $datetime, $tag, $msg) = @_;
	my $priority = ($facility << 3) + $severity;
	return "<$priority>$datetime $tag $msg\x00";
}

sub logwall {
	my $client = $_[0];
	($logline, $powner, $pgroup, $uid, $gid, $owner, $group, $comm) = undef;

	if(defined $puid) { ($powner) = getpwuid $puid; }
	if(defined $pgid) { ($pgroup) = getgrgid $pgid; }
	if(defined $exe) {
		($uid, $gid) = ((stat $exe)[STAT_UID, STAT_GID]);
		($owner) = getpwuid $uid;
		($group) = getgrgid $gid;
	}
	$args =~ s/[^\x20-\x7E]/sprintf '\x%02X', ord$&/eg;

	open $fh, '<', "/proc/$realpid/comm";
	$comm .= $_ while <$fh>;
	close $fh;
	if(defined $comm) {
		my $tmpstr = $comm;
		$tmpstr =~ s/[\x00]/ /g;
		$tmpstr =~ s/[\x0A\x0D]//g;
		$tmpstr =~ s/[^\x20-\x7E]/./g;
		$0 .= " ($tmpstr)";
		undef $tmpstr;
	}

	socket($backend, AF_UNIX, SOCK_DGRAM, 0) or warn $!;
	select $backend; $|++; select STDOUT;
	connect($backend, $sock_connect_addr) or warn $!;
	
	local $/ = "\x00";
	while(<$client>) {
		($facility, $severity, $datetime, $tag, $sourcename, $pid, $msg) = undef;
		my $pass = 1;
		my %rw;

		$logline = $_;
		s/\x00$//;
		if(/^<(?'priority'\d+)>\s*(?'datetime'\S+\s+\S+\s+\S+)\s+(?'tag'\S+) /) {
			$msg = $';
			my $priority = $+{'priority'};
			$datetime = $+{'datetime'};
			$tag = $+{'tag'};
			$facility = $priority >> 3;
			$severity = $priority & 7;
			($sourcename) = ($tag =~ /^([a-z0-9_\.,\/><-]+)/i);
			($pid) = ($tag =~ /\[(\d+)\]:?$/);
		}
		else {
			# FIXME: invalid logline
		}
		
		seek $rules, 0, 0;
		local $/ = "\n";
		$nl = 0;
		RULES:
		while(<$rules>) {
			$nl++;
			
			TESTS:
			while(1) {
			    if(/^\s*([a-z]+)(==|!=|=~|=|!~|>=|<=|>|<|:=|^=|\+=)("[^""]*"|\S*)/) {
				$_ = $';
				my ($test, $op, $value) = ($1, $2, $3);
				$value =~ /"([^""]+)"/ and $value = $1;
				$test = lc $test;
				
				# convert string represented facility to facility number
				if($test eq 'facility' and $value !~ /^\d+$/) {
					if(not exists $facnum{$value}) { yell 3, "valid facility values: ".(join ', ', @facnam); }
					$value = $facnum{$value};
				}
				# convert string represented severity to severity number
				elsif($test =~ /^severity|rwlog|log$/ and $value !~ /^\d+$/) {
					if(not exists $sevnum{$value}) { yell 3, "valid severity values: ".(join ', ', @sevnam); }
					$value = $sevnum{$value};
				}


				if($test eq 'then') {
					$value = lc $value;
					if($value eq 'drop') { $pass = 0; last RULES; }
					elsif($value eq 'accept') { $pass = 1; last RULES; }
					else { yell 3, "keyword 'then' takes arguments: drop, accept"; }
				}
				elsif($test eq 'log') {
					yell $value, sprintf "realpid=$realpid puid=$puid pgid=$pgid powner=$powner pgroup=$pgroup ".
						"exe=$exe args=%s uid=$uid gid=$gid owner=$owner group=$group ".
						"facility=%s severity=%s tag=$tag sourcename=$sourcename pid=$pid", 
						$args, $facnam[$facility], $sevnam[$severity];
				}
				elsif($test eq 'rwlog') {
					yell $value, sprintf "facility=%s severity=%s tag=%s sourcename=%s pid=%s",
						defined $rw{'facility'} ? $facnam[$rw{'facility'}] : "($facnam[$facility])",
						defined $rw{'severity'} ? $sevnam[$rw{'severity'}] : "($sevnam[$severity])",
						defined $rw{'tag'} ? $rw{'tag'} : "($tag)",
						defined $rw{'sourcename'} ? $rw{'sourcename'} : "($sourcename)",
						defined $rw{'pid'} ? $rw{'pid'} : "($pid)";
				}
				
				elsif($test =~ /^exe|powner|pgroup|owner|group|tag|sourcename|msg$/) {
					$testx = $$test;
					if($op eq '==') { last TESTS unless $testx eq $value; }
					elsif($op eq '!=') { last TESTS unless $testx ne $value; }
					elsif($op eq '=~') { last TESTS unless $testx =~ /$value/; }
					elsif($op eq '!~') { last TESTS unless $testx !~ /$value/; }
					elsif($op eq ':=' or $op eq '^=' or $op eq '+=') {
						if($test =~ /^tag|sourcename|msg$/) {
							$rw{$test} = $value if $op eq ':=';
							$rw{$test} = $value.$testx if $op eq '^=';
							$rw{$test} = $testx.$value if $op eq '+=';
						}
						else {
							yell 3, "can not rewrite '$test' on line $nl";
						}
					}
					else {
						yell 3, "keyword '$test' takes string comparasion operator, but '$op' given on line $nl";
						last TESTS;
					}
				}
				elsif($test =~ /^realpid|puid|pgid|uid|gid|facility|severity|pid$/) {
					$testx = $$test;
					$value = int $value;
					if($op =~ /^==|!=|>=|<=|>|<$/) {
						last TESTS unless eval qq{$testx $op $value};
					}
					elsif($op eq ':=') {
						if($test =~ /^facility|severity|pid$/) {
							$rw{$test} = $value;
						}
						else {
							yell 3, "can not rewrite '$test' on line $nl";
							last TESTS;
						}
					}
					else {
						yell 3, "keyword '$test' takes numeric relation operator, nut '$op' given on line $nl";
						last TESTS;
					}

				}
				else {
					yell 3, "bareword in $file_rules on line $nl; valid keywords: realpid, puid, pgid, powner, pgroup, exe, uid, gid, owner, group, facility, severity, tag, sourcename, pid, msg, then, log";
				}
			    }
			    else {
				s/\s*$//;
				s/\s*(\x23.*)?$//;
				if(length) {
					yell 3, "parse syntax error in $file_rules on line $nl near '$_'";
				}
				last TESTS;
			    }
			}
		}
	
		if($pass) {
			for my $var (qw/facility severity datetime pid msg/) {
				$$var = defined $rw{$var} ? $rw{$var} : $$var;
			}
			if(defined $rw{'tag'}) {
				$tag = $rw{'tag'};
			}
			else {
				if(defined $rw{'sourcename'}) {
					$tag = $rw{'sourcename'};
				}
				else {
					($tag) = ($tag =~ /^([^:[]+)/);
				}
				if(defined $pid and $pid ne "") {
					$tag .= "[$pid]";
				}
				$tag .= ":";
			}
			print $backend mklogline($facility, $severity, $datetime, $tag, $msg);
		}
	}
	
	close $backend;
	close $client;
}


$SIG{'CHLD'} = \&bury;
sub bury {
	my @new;
	for(@kids) {
		my $w = waitpid $_, WNOHANG;
		if($w == 0) { push @new, $_; }
	}
	@kids = @new;
}




$sock_listen_addr = sockaddr_un($sock_listen);
$sock_connect_addr = sockaddr_un($sock_connect);

print STDERR "Ruleset: $file_rules: " if !$quiet;
open($rules, '<', $file_rules) or die "$!";
print STDERR "OK\n" if !$quiet;

print STDERR "Frontend: $sock_listen: " if !$quiet;
#socket($frontend, AF_UNIX, SOCK_DGRAM, 0)
socket($frontend, AF_UNIX, SOCK_STREAM, 0)
  or die "$!";
unlink($sock_listen);
bind($frontend, $sock_listen_addr) or die "$!";
chmod(0666, $sock_listen) or warn "$!";
chmod(0660, $sock_connect) or warn "$!";
listen($frontend, SOMAXCONN) or die "$!";
print STDERR "OK\n" if !$quiet;

chdir "/";
$fork = fork;
if($fork == 0) {
    undef $fork;
    ACCEPT:
	undef $args;
	1 while not accept($client, $frontend);

	##<< Race-Condition >>##
	($realpid, $puid, $pgid) = unpack('lll', getsockopt($client, SOL_SOCKET, SO_PEERCRED));
	$exe = readlink "/proc/$realpid/exe";
	open $fh, '<', "/proc/$realpid/cmdline";
	$args .= $_ while <$fh>;
	close $fh;
	
	$kid = fork;
	if(not defined $kid) {
		warn $!;
	}
	elsif(not $kid) {
		logwall $client;
		exit;
	}
	else {
		push @kids, $kid;
	}
    goto ACCEPT;
}

open PIDFILE, '>', "/var/run/logwall.pid";
print PIDFILE $fork;
close PIDFILE;
print STDERR "logwall started, pid $fork\n" if !$quiet;

